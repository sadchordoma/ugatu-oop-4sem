# Лабораторная работа 5. «Жизненный цикл объектов С++ и Виртуальность»
## Тип приложения: консольное; язык: c++.
- Определение и реализация тестовых классов, и написание программы, иллюстрирующей их использование. Лабораторная работа должна включать несколько программ, по мере изучения соответствующих понятий из лекционного курса, не стоит пытаться писать все сразу в одну программу и строго последовательно.

-	Определения
-	перекрываемых методов (показать на примере случай, когда вызывается перекрываемый метод, а когда наследуемый)
-	виртуальных методов, в т.ч. деструкторов (показать на примере, когда вызывается наследуемый виртуальный метод, а когда базовый)
-	Реализация
-	проверки на принадлежность некоторому классу
-	безопасного приведения типов (dynamic_cast)
-	безопасного приведения типов (вручную)
-	Передача объектов как параметров в функции и возвращения объектов как - результата из функции, контроль их жизненного цикла
-	Умные указатели unique_ptr и shared_ptr, их влияние на жизненный цикл объектов

## В рамках лабораторной работы необходимо написать достаточно примеров, чтобы разобраться и понимать, например, суть того, что будет, если:
-	создать в классе-предке виртуальный конструктор и виртуальный деструктор, зачем нужен виртуальный деструктор и как он работает?
-	в методе1 базового класса вызывается метод2, который определен в этом же классе как невиртуальный, у класса-потомка метод2 переопределен: что происходит при вызове метода1 у класса-потомка?
-	в методе1 базового класса вызывается метод2, который определен в этом же классе как виртуальный, у класса-потомка метод2 переопределен: что происходит при вызове метода1 у класса-потомка?
-	в базовом классе объявить метод невиртуальный, а в классе-потомке объявить метод с таким же именем: какой метод будет вызываться при обращении к объекту через указатель на базовый класс, через указатель на класс-потомок?
-	в базовом классе объявить метод виртуальный, а в классе-потомке объявить метод с таким же именем: какой метод будет вызываться при обращении к объекту через указатель на базовый класс, через указатель на класс-потомок?

## Проиллюстрировать примерами кода и уметь давать ответы на следующие вопросы:
-	Зачем нужны виртуальные методы? Зачем может понадобиться хранить объект не в указателе на свой собственный класс, а указателе на класс-предок?
-	Зачем нужна проверка на принадлежность некоторому классу?
-	Зачем и в каких случаях требуется производить безопасное приведение типов? В каком случае может понадобиться вызвать метод потомка для объекта, который лежит в переменной предка?

## Для проверки на принадлежность некоторому классу необходимо реализовать:
-	базовый виртуальный метод string classname(), перекрыть его в потомках, проверить работу и показать, какие проблемы возникают при его использовании;
-	базовый виртуальный метод bool isA(string classname), перекрыть его в потомках и показать отличие от метода classname.

## Продемонстрировать 
- опасное приведение типов и предварительную проверку типа с помощью реализованного метода isA. Продемонстрировать использование стандартных средств языка (dynamic_cast в c++ или аналог на используемом языке).

## Для проверки механизма передачи объектов
- как параметров в функции необходимо написать три функции (отдельные функции, а не методы класса):

1)void func1(Base  obj) { ... };

2)void func2(Base *obj) { ... };

3)void func3(Base &obj) { ... };

## Далее необходимо создать простой класс Base и его потомок Desc и реализовать в каждом из них три конструктора и по одному деструктору (в каждой из трех функций и во всех конструкторах и деструкторе должен быть отладочный вывод в консоль!):

Base() { ... };

Base(Base *obj) { ... };

Base(Base &obj) { ... };

~Base() { ... };

Desc() { ... };

Desc(Desc *obj) { ... };

Desc(Desc &obj) { ... };

~Desc() { ... };

## После этого необходимо создавать объекты классов Base и Desc
- и передавать их в каждую из трех функций, объясняя при этом, когда и почему вызывается какой конструктор или деструктор. Можно ли внутри функции привести переданный Base к Desc с помощью приведения типов? Необходимо уметь объяснять достоинства и недостатки каждого из вариантов функции.

## Для проверки механизма возврата объектов из функции необходимо написать шесть функций (отдельных функций, а не методов класса):

Base func1() { ... };

Base* func2() { ... };

Base& func3() { ... };

Base func4() { ... };

Base* func5() { ... };

Base& func6() { ... };

#### Внутри функций 1,2,3 необходимо создавать и возвращать статический (локальный) объект, внутри функций 4,5,6 возвращаемый объект необходимо создавать динамически с помощью new. Затем необходимо помещать результат вызова каждой из этих трёх функций в локальную переменную и объяснять наблюдаемый отладочный вывод (показывающий последовательность создания и удаления объектов). Необходимо уметь объяснять достоинства и недостатки каждого из вариантов, в том числе уметь идентифицировать неправильную работу с памятью.

## Для изучения умных указателей необходимо 
- #### создать объекты, управляемые с помощью unique_ptr и shared_ptr (с помощью make_unique и make_shared и/или без них), помещать их в переменные, передавать их в функции, возвращать их из функций и демонстрировать, как они влияют на время жизни объекта, которым управляют.
