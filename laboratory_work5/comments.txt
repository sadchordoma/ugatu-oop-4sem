Проблема поверхностного и глубокого копирования
Правило 3 ( конструктор копирования, оператор присваивания, деструктор)
Правило 0 ( если можно без всего этого - то это лучше)
Правило 5 ( Правило 3 + конструктор перемещения, оператор перемещения)

Помещение одного типа в другой тип
Объекты-потомки можно записывать в переменные-предки, но функционал будет
только из переменных-предков.

Полиморфизм

В С++ при помещении потомка в предка и вызова переопределенного у потомка метода,
все равно вызовётся метод предка

virtual for method in abstract Class ( с которого наследуемся)
( Объявляя метод virtual, мы говорим, ЭТОТ МЕТОД БУДЕТ ПЕРЕКРЫВАТЬСЯ В ПОТОМКАХ
 и если для какого-то указателя предка он будет вызываться, то вызови не базовый метод,
 а метод того объекта, который по этому адресу лежит)

override - перекрывать - для предотвращения неправильного именования метода и прямого указания
компилятору что я перекрываю виртуальный метод базового класса

Все написанное выше справедливо для С++. В других языках по дефолту все методы виртуальные

virtual void sound() = 0; - чистый виртуальный метод (абстрактный метод)
1 абстрактный метод => абстрактный класс => невозможно создать объект такого класса

Поэтому если мы унаследуемся от абстрактного класса, но забудем перекрыть
хотя бы один абстрактный метод, объекты нашего класса создавать будет нельзя, компилятор не позволит. В этом и задумка.
