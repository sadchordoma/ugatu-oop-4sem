animals ---	Определения
          -	перекрываемых методов (показать на примере случай, когда вызывается перекрываемый метод, а когда наследуемый)
          -	виртуальных методов, в т.ч. деструкторов (показать на примере, когда вызывается наследуемый виртуальный метод, а когда базовый)

birds - Для проверки на принадлежность некоторому классу необходимо реализовать:
        •	базовый виртуальный метод string classname(), перекрыть его в потомках, проверить работу и показать, какие проблемы возникают при его использовании;
        •	базовый виртуальный метод bool isA(string classname), перекрыть его в потомках и показать отличие от метода classname.
        o	безопасного приведения типов (вручную)
        Продемонстрировать опасное приведение типов и предварительную проверку типа с помощью реализованного метода isA. Продемонстрировать использование стандартных средств языка (dynamic_cast в c++ или аналог на используемом языке).

object - •	Передача объектов как параметров в функции и возвращения объектов как результата из функции, контроль их жизненного цикла
         •	Умные указатели unique_ptr и shared_ptr, их влияние на жизненный цикл объектов


    int a = 1;
    int *p = &a;
    std::cout << a << " " << "*a doesn't work " << &a << "\n";
    std::cout << p << " " << *p << " " << &p << "\n";

    1               *a doesn't work                 0xf6a47ff89c
    0xf6a47ff89c        1                           0xf6a47ff890

В переменную класса А можно положить любой объект класса А или любого Б из
его классов-потомков.
Объект класса А можно положить в любую переменную класса А или любого Б из его
классов-предков. Это одно и то же правило, просто прочитанное с разных сторон.


base - Для проверки механизма передачи объектов как параметров в функции необходимо
написать три функции (отдельные функции, а не методы класса): void func1(Base  obj)
{ ... }; void func2(Base *obj) { ... }; void func3(Base &obj) { ... };
Далее необходимо создать простой класс Base и его потомок Desc и реализовать
в каждом из них три конструктора и по одному деструктору (в каждой из трех функций
и во всех конструкторах и деструкторе должен быть отладочный вывод в консоль!):
Base() { ... }; Base(Base *obj) { ... }; Base(Base &obj) { ... }; ~Base() { ... };
Desc() { ... }; Desc(Desc *obj) { ... }; Desc(Desc &obj) { ... }; ~Desc() { ... };
После этого необходимо создавать объекты классов Base и Desc, и передавать их в каждую
из трех функций, объясняя при этом, когда и почему вызывается какой конструктор или деструктор.
Можно ли внутри функции привести переданный Base к Desc с помощью приведения типов?
Необходимо уметь объяснять достоинства и недостатки каждого из вариантов функции.
Для проверки механизма возврата объектов из функции необходимо написать шесть функций
(отдельных функций, а не методов класса): Base func1() { ... }; Base* func2() { ... };
Base& func3() { ... }; Base func4() { ... }; Base* func5() { ... }; Base& func6() { ... };
Внутри функций 1,2,3 необходимо создавать и возвращать статический (локальный) объект,
внутри функций 4,5,6 возвращаемый объект необходимо создавать динамически с помощью new.
Затем необходимо помещать результат вызова каждой из этих трёх функций в локальную переменную
и объяснять наблюдаемый отладочный вывод (показывающий последовательность создания и удаления
объектов). Необходимо уметь объяснять достоинства и недостатки каждого из вариантов, в том
числе уметь идентифицировать неправильную работу с памятью

/////////////////////////////////
При возвращении из функции (константной или неокнстантной) ссылки нужно учитывать три момента:
    При возврате объекта вызывается конструктор копирования, а при возврате ссылки — нет.
    при выполнении вызываемой функции ссылка должна указывать на существующий объект.

При передачи в функцию - копия создается через оператор копирования
